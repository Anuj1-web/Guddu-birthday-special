<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Guddu's Endless Surprise Garden</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- THREE.js -->
  <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.155.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.155.0/examples/js/geometries/TextGeometry.js"></script>

  <style>
    body { margin:0; overflow:hidden; background:black; }
    canvas { display:block; }
  </style>
</head>
<body>
<script>
  // ---------------- CONFIG ----------------
  const HOARDING_IMAGES = [
    "https://www.dropbox.com/scl/fi/u98gnws5gdqjxqoln440b/IMG-20250815-WA0010.jpg?raw=1",
    "https://www.dropbox.com/scl/fi/cov38hf9qc6cy4e4c4io9/IMG-20250815-WA0000.jpg?raw=1",
    "https://www.dropbox.com/scl/fi/2mcpq9fuoqqdrfncxo17f/IMG-20250304-WA0006.jpg?raw=1",
    "https://www.dropbox.com/scl/fi/pnr4hg3cszl67aojrz5yb/IMG-20250815-WA0008.jpg?raw=1",
    "https://www.dropbox.com/scl/fi/0a1ckwv332kos7s2koy3n/IMG-20250815-WA0003.jpg?raw=1"
  ];

  const CHUNK_LEN = 50;
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // ---------------- CONTROLS ----------------
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 2, -5);
  camera.position.set(0, 3, 10);

  // ---------------- LIGHTING ----------------
  const ambient = new THREE.AmbientLight(0x666666);
  scene.add(ambient);
  const sun = new THREE.DirectionalLight(0xffffff, 1);
  sun.position.set(50,100,0);
  scene.add(sun);

  // ---------------- GROUND WITH GRASS ----------------
  const groundGeo = new THREE.PlaneGeometry(200,200);
  const groundMat = new THREE.MeshLambertMaterial({color:0x228822});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // grass blades
  const grassGeo = new THREE.PlaneGeometry(0.1,0.5);
  const grassMat = new THREE.MeshBasicMaterial({color:0x44aa44, side:THREE.DoubleSide});
  for (let i=0;i<2000;i++){
    const blade = new THREE.Mesh(grassGeo, grassMat);
    blade.position.set((Math.random()-0.5)*200,0,(Math.random()-0.5)*200);
    blade.rotation.y = Math.random()*Math.PI;
    scene.add(blade);
  }

  // ---------------- TREES ----------------
  function createTree(x,z){
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.5,4), new THREE.MeshLambertMaterial({color:0x8b5a2b}));
    trunk.position.set(x,2,z);
    scene.add(trunk);
    const leaves = new THREE.Mesh(new THREE.SphereGeometry(2,12,12), new THREE.MeshLambertMaterial({color:0x228b22}));
    leaves.position.set(x,5,z);
    scene.add(leaves);
    return leaves;
  }
  createTree(-5,-10);
  createTree(6,-30);
  createTree(-8,-50);

  // ---------------- HOARDINGS ----------------
  const texLoader = new THREE.TextureLoader();
  function makeHoarding(tex){
    const mat = new THREE.MeshBasicMaterial({map:tex, side:THREE.DoubleSide});
    const geo = new THREE.PlaneGeometry(8,6);
    return new THREE.Mesh(geo, mat);
  }

  function addHoarding(z){
    const idx = Math.floor(Math.random()*HOARDING_IMAGES.length);
    const tex = texLoader.load(HOARDING_IMAGES[idx]);
    const h = makeHoarding(tex);
    const side = Math.random()>0.5 ? -1:1;
    h.position.set(side*6,3,z);
    scene.add(h);
  }

  // ---------------- GIFT BOX ----------------
  function createGift(x,z){
    const geo = new THREE.BoxGeometry(1,1,1);
    const mat = new THREE.MeshLambertMaterial({color:0xff0000});
    const box = new THREE.Mesh(geo,mat);
    box.position.set(x,0.5,z);
    scene.add(box);

    box.userData.isGift=true;
    return box;
  }

  // ---------------- BUTTERFLIES ----------------
  const butterflies=[];
  function createButterfly(){
    const geo=new THREE.PlaneGeometry(0.5,0.5);
    const mat=new THREE.MeshBasicMaterial({color:0xff00ff, side:THREE.DoubleSide});
    const b=new THREE.Mesh(geo,mat);
    b.position.set((Math.random()-0.5)*10,2+Math.random()*2,(Math.random()-0.5)*10);
    scene.add(b);
    butterflies.push(b);
  }
  for(let i=0;i<10;i++) createButterfly();

  // ---------------- BIRDS ----------------
  const birdGeo=new THREE.ConeGeometry(0.2,0.5,8);
  const birdMat=new THREE.MeshLambertMaterial({color:0x0000ff});
  const birds=[];
  for(let i=0;i<5;i++){
    const b=new THREE.Mesh(birdGeo,birdMat);
    b.position.set(-5+Math.random()*10,5+Math.random()*2,-20-Math.random()*20);
    scene.add(b);
    birds.push(b);
  }

  // ---------------- ENDLESS PATH ----------------
  let chunkIndex=0;
  function generateChunk(){
    const z = -chunkIndex*CHUNK_LEN;

    // path
    const pathGeo=new THREE.PlaneGeometry(4,CHUNK_LEN);
    const pathMat=new THREE.MeshLambertMaterial({color:0x444444});
    const path=new THREE.Mesh(pathGeo,pathMat);
    path.rotation.x=-Math.PI/2;
    path.position.z=z-CHUNK_LEN/2;
    scene.add(path);

    if(chunkIndex%2===0) addHoarding(z-CHUNK_LEN/2+10);
    if(Math.random()>0.7) createGift((Math.random()>0.5?2:-2),z-20);

    chunkIndex++;
  }
  for(let i=0;i<5;i++) generateChunk();

  // ---------------- INTERACTIONS ----------------
  const raycaster=new THREE.Raycaster();
  const mouse=new THREE.Vector2();
  window.addEventListener("click",(e)=>{
    mouse.x=(e.clientX/window.innerWidth)*2-1;
    mouse.y=-(e.clientY/window.innerHeight)*2+1;
    raycaster.setFromCamera(mouse,camera);
    const intersects=raycaster.intersectObjects(scene.children);
    if(intersects.length>0){
      const obj=intersects[0].object;
      if(obj.userData.isGift){
        alert("🎁 Surprise for Guddu! 💖");
      }
    }
  });

  // ---------------- ANIMATION LOOP ----------------
  function animate(){
    requestAnimationFrame(animate);
    controls.update();

    // butterflies
    butterflies.forEach(b=>{
      b.position.x+=Math.sin(Date.now()*0.001+b.position.z)*0.01;
      b.position.y+=Math.cos(Date.now()*0.001+b.position.x)*0.01;
    });

    // move camera forward
    camera.position.z-=0.05;
    if(camera.position.z < -chunkIndex*CHUNK_LEN + 100){
      generateChunk();
    }

    renderer.render(scene,camera);
  }
  animate();

</script>
</body>
</html>
