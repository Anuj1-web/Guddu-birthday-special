<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>🌸 Guddu’s 3D Love Garden</title>
  <style>
    html, body { height: 100%; }
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 500px at 20% -10%, #2a2a69 10%, #0f1427 60%, #0a0f1f 100%);
      color: #fff;
    }
    #loading {
      position: fixed; inset: 0; display:flex; align-items:center; justify-content:center;
      pointer-events:none; font-weight:600; letter-spacing:.2px;
      background: linear-gradient(180deg, rgba(9,11,22,.9), rgba(9,11,22,.35));
      backdrop-filter: blur(2px);
    }
    #toast {
      position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
      padding: 10px 14px; border-radius: 10px; background: rgba(0,0,0,.6);
      font-size: 13px; opacity: 0; transition: opacity .25s ease;
      pointer-events: none; white-space: nowrap;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="loading">🌱 Growing your magical garden…</div>
  <div id="toast"></div>

  <!-- Use your local copies in the same folder -->
  <script src="./three.min.js"></script>
  <script src="./OrbitControls.js"></script>

  <script>
  (function () {
    // ----- Guards ------------------------------------------------------------
    if (!window.THREE) {
      showToast("Three.js failed to load. Put three.min.js next to this file.");
      return;
    }
    if (!THREE.OrbitControls) {
      showToast("OrbitControls failed to load. Put OrbitControls.js next to this file.");
      return;
    }

    // ----- Scene basics ------------------------------------------------------
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a0f1f, 15, 80);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.shadowMap.enabled = true;
    // modern color management
    if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(8, 6, 12);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0.5, 0);

    // ----- Lights ------------------------------------------------------------
    const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.6);
    scene.add(hemi);

    const key = new THREE.DirectionalLight(0xfff2e0, 0.9);
    key.position.set(6, 10, 4);
    key.castShadow = true;
    key.shadow.mapSize.set(1024, 1024);
    scene.add(key);

    const rim = new THREE.PointLight(0x88bbff, 0.5, 30, 2);
    rim.position.set(-6, 4, -5);
    scene.add(rim);

    // ----- Ground ------------------------------------------------------------
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x215a2b, roughness: 1, metalness: 0 });
    const ground = new THREE.Mesh(new THREE.CircleGeometry(24, 96), groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Cute path
    const path = new THREE.Mesh(new THREE.RingGeometry(6, 7.2, 80), new THREE.MeshStandardMaterial({ color: 0x9c7b59, roughness: .95 }));
    path.rotation.x = -Math.PI/2;
    path.position.y = 0.001;
    scene.add(path);

    // ----- Helpers to make sprites with canvas (no CORS) ---------------------
    function makeTextSprite(text, options = {}) {
      const {
        font = "700 22px Poppins, system-ui, Arial",
        padding = 16,
        fill = "#ffffff",
        stroke = "#ff62a6",
        bg = "rgba(10,12,24,0.75)"
      } = options;

      const lines = String(text).split(/\n/);
      const ctx = document.createElement("canvas").getContext("2d");
      ctx.font = font;
      const metrics = lines.map(l => ctx.measureText(l).width);
      const w = Math.ceil(Math.max(...metrics) + padding * 2);
      const h = Math.ceil(lines.length * 28 + padding * 2);

      ctx.canvas.width = w * 2; ctx.canvas.height = h * 2;
      ctx.scale(2, 2);
      ctx.font = font;
      // bg
      ctx.fillStyle = bg;
      roundRect(ctx, 0, 0, w, h, 12, true, false);
      // glow stroke
      ctx.strokeStyle = stroke; ctx.lineWidth = 3;
      roundRect(ctx, 1.5, 1.5, w-3, h-3, 10, false, true);
      // text
      ctx.fillStyle = fill; ctx.textBaseline = "top";
      lines.forEach((l, i) => ctx.fillText(l, padding, padding + i * 28));

      const tex = new THREE.CanvasTexture(ctx.canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sprite = new THREE.Sprite(mat);
      const scale = 0.01; // size in world units per pixel
      sprite.scale.set(w * scale, h * scale, 1);
      sprite.renderOrder = 999; // draw on top
      sprite.userData.__isMessage = true;
      return sprite;
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      r = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // ----- Fairy dust (lightweight particle bursts) --------------------------
    const dustBursts = [];
    function spawnFairyDust(position, color = 0xff9ed5) {
      const count = 120;
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const velocities = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * 0.2;
        positions[i*3+0] = position.x + Math.cos(a) * r;
        positions[i*3+1] = position.y + Math.random() * 0.2 + 0.2;
        positions[i*3+2] = position.z + Math.sin(a) * r;
        velocities[i*3+0] = (Math.random() - .5) * 0.25;
        velocities[i*3+1] = Math.random() * 0.6 + 0.2;
        velocities[i*3+2] = (Math.random() - .5) * 0.25;
      }
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geo.setAttribute("velocity", new THREE.BufferAttribute(velocities, 3));
      const mat = new THREE.PointsMaterial({ size: 0.035, color, transparent: true, opacity: 1 });
      const pts = new THREE.Points(geo, mat);
      pts.userData.birth = clock.getElapsedTime();
      scene.add(pts);
      dustBursts.push(pts);
    }

    // ----- Flower factory (procedural, no textures) --------------------------
    const clickable = [];

    function makeFlower(x, z, opts = {}) {
      const { petalColor = 0xff6fb4, centerColor = 0xffe082, stemColor = 0x2e7d32, message = "You are loved!" } = opts;
      const g = new THREE.Group();
      g.position.set(x, 0, z);

      // stem
      const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 1.2, 12), new THREE.MeshStandardMaterial({ color: stemColor, roughness:.9 }));
      stem.position.y = 0.6;
      stem.castShadow = true; stem.receiveShadow = true;
      g.add(stem);

      // petals
      const petals = new THREE.Group();
      const petalGeo = new THREE.ConeGeometry(0.2, 0.4, 16);
      const petalMat = new THREE.MeshStandardMaterial({ color: petalColor, roughness:.6, metalness:.1 });
      for (let i = 0; i < 8; i++) {
        const p = new THREE.Mesh(petalGeo, petalMat);
        p.position.set(Math.cos(i*Math.PI/4)*0.23, 1.25, Math.sin(i*Math.PI/4)*0.23);
        p.rotation.z = Math.PI; // point outward
        p.lookAt(g.position.x, 1.25, g.position.z);
        p.castShadow = true;
        petals.add(p);
      }
      g.add(petals);

      // center
      const center = new THREE.Mesh(new THREE.SphereGeometry(0.18, 24, 16), new THREE.MeshStandardMaterial({ color: centerColor, emissive: 0x331122, emissiveIntensity:.15 }));
      center.position.y = 1.25;
      center.castShadow = true;
      g.add(center);

      // little leaves
      const leafGeo = new THREE.SphereGeometry(0.12, 16, 12);
      const leafMat = new THREE.MeshStandardMaterial({ color: 0x3aa94f, roughness:.9 });
      const leaf1 = new THREE.Mesh(leafGeo, leafMat); leaf1.position.set(0.16, 0.6, 0); leaf1.scale.set(1.2,0.5,1.0);
      const leaf2 = leaf1.clone(); leaf2.position.x *= -1;
      g.add(leaf1, leaf2);

      g.userData = { type: "flower", opened: false, message };
      clickable.push(g);
      scene.add(g);
      return g;
    }

    // ----- Gift box / chocolate ---------------------------------------------
    function makeGiftBox(x, z, message) {
      const box = new THREE.Group(); box.position.set(x, 0.01, z);
      const base = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.5, 0.9), new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: .6, roughness: .3 }));
      base.position.y = 0.25; base.castShadow = true; base.receiveShadow = true;
      const lid = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.18, 0.95), new THREE.MeshStandardMaterial({ color: 0xfdd835, metalness: .4, roughness:.4 }));
      lid.position.y = 0.59; lid.castShadow = true;
      box.add(base, lid);
      box.userData = { type: "gift", lid, openT: 0, message };
      clickable.push(box);
      scene.add(box);
      return box;
    }

    function makeChocolate(x, z, message) {
      const g = new THREE.Group(); g.position.set(x, 0.01, z);
      const choc = new THREE.Mesh(new THREE.CylinderGeometry(0.32, 0.32, 0.28, 24), new THREE.MeshStandardMaterial({ color: 0x5d321a, metalness: 0.2, roughness: 0.6 }));
      choc.position.y = 0.14; choc.castShadow = true; choc.receiveShadow = true;
      const wrap = new THREE.Mesh(new THREE.TorusGeometry(0.32, 0.07, 14, 18), new THREE.MeshStandardMaterial({ color: 0xf06292, metalness: 0.6, roughness: 0.3 }));
      wrap.rotation.x = Math.PI/2; wrap.position.y = 0.28;
      g.add(choc, wrap);
      g.userData = { type: "choc", message };
      clickable.push(g);
      scene.add(g);
      return g;
    }

    // ----- Messages & interactions ------------------------------------------
    const activeMessages = new Set();

    function showMessageAt(object, text, colorStroke = "#ff6fb4") {
      // remove any prior message on this object
      const prior = object.children.find(c => c.userData && c.userData.__isMessage);
      if (prior) object.remove(prior);

      const sprite = makeTextSprite(text, { stroke: colorStroke });
      sprite.position.set(0, 1.9, 0);
      sprite.material.opacity = 0;
      object.add(sprite);
      activeMessages.add(sprite);

      // small rise animation
      object.userData.__riseT = 0;
      spawnFairyDust(object.getWorldPosition(new THREE.Vector3()));

      // fade in
      sprite.userData.fade = { t: 0, dir: 1 };
    }

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function onPointerDown(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(clickable, true);
      if (!intersects.length) return;

      const obj = intersects[0].object.parent.type === "Group" ? intersects[0].object.parent : intersects[0].object;
      const root = clickable.find(g => obj === g || obj.parent === g || obj.parent?.parent === g) || obj;

      if (root.userData.type === "flower") {
        if (!root.userData.opened) {
          root.userData.opened = true;
          showMessageAt(root, root.userData.message);
        } else {
          // toggle off
          const m = root.children.find(c => c.userData && c.userData.__isMessage);
          if (m) root.remove(m);
          root.userData.opened = false;
        }
      } else if (root.userData.type === "gift") {
        root.userData.openT = Math.min(1, root.userData.openT + 1); // open once
        showMessageAt(root, root.userData.message, "#ffd54f");
      } else if (root.userData.type === "choc") {
        showMessageAt(root, root.userData.message, "#a5d6a7");
      }
    }
    renderer.domElement.addEventListener("pointerdown", onPointerDown);

    // ----- Populate garden ---------------------------------------------------
    const msgs = [
      "You are my favorite\nperson in the universe ✨",
      "Every petal says:\nI love you 💖",
      "Your smile = instant sunshine ☀️",
      "You make ordinary days magical 🌟",
      "With you, forever feels short 💫",
      "Happy moments grow like flowers with you 🌸"
    ];

    // flowers scattered in a ring
    for (let i = 0; i < 26; i++) {
      const a = (i / 26) * Math.PI * 2;
      const r = 10 + (Math.random() * 4 - 2);
      const x = Math.cos(a) * r + (Math.random() - .5) * 0.6;
      const z = Math.sin(a) * r + (Math.random() - .5) * 0.6;
      const petal = new THREE.Color().setHSL((i / 26 + Math.random() * .1) % 1, 0.7, 0.6);
      makeFlower(x, z, { petalColor: petal.getHex(), message: msgs[i % msgs.length] });
    }

    // a cluster near the center
    for (let i = 0; i < 8; i++) {
      const x = (Math.random() - .5) * 4;
      const z = (Math.random() - .5) * 4;
      makeFlower(x, z, { petalColor: 0xff8fa0, message: "You are precious, Guddu 💗" });
    }

    // gifts & chocolates (surprises)
    makeGiftBox(-3.5, -5.5, "A surprise for you 🎁\nLet’s celebrate your day!");
    makeGiftBox(6.2, 5.0, "My heart is wrapped for you 💛");
    makeChocolate(2.3, -6.3, "Sweet like your laugh 🍫");
    makeChocolate(-7.2, 3.4, "One more chocolate hug!");

    // cute heart at center
    const heart = (() => {
      const s = new THREE.Shape();
      s.moveTo(0, 0.25);
      s.bezierCurveTo(0, 0.25, -0.3, 0, -0.6, 0.25);
      s.bezierCurveTo(-0.9, 0.55, -0.6, 0.9, 0, 1.1);
      s.bezierCurveTo(0.6, 0.9, 0.9, 0.55, 0.6, 0.25);
      s.bezierCurveTo(0.3, 0, 0, 0.25, 0, 0.25);
      const geo = new THREE.ExtrudeGeometry(s, { depth: 0.22, bevelEnabled: true, bevelSize: 0.04, bevelThickness: 0.04, steps: 1 });
      const mat = new THREE.MeshStandardMaterial({ color: 0xff4d93, metalness:.1, roughness:.35, emissive:0x240215, emissiveIntensity:.2 });
      const m = new THREE.Mesh(geo, mat);
      m.castShadow = true; m.position.set(0, 0.25, 0); m.rotation.y = Math.PI/8;
      scene.add(m);
      return m;
    })();

    // ----- Animate -----------------------------------------------------------
    const clock = new THREE.Clock();
    const tmp = new THREE.Vector3();

    function animate() {
      const dt = Math.min(0.033, clock.getDelta());

      // gentle heart spin
      heart.rotation.y += dt * 0.6;

      // controls damping
      controls.update();

      // gift lid animation
      for (const g of clickable) {
        if (g.userData.type === "gift" && g.userData.openT > 0) {
          const lid = g.userData.lid;
          lid.rotation.z = Math.min(Math.PI * 0.9, lid.rotation.z + dt * 1.6);
          lid.position.y = Math.min(1.1, lid.position.y + dt * 0.5);
        }
        // flower rise effect
        if (g.userData.__riseT !== undefined && g.userData.__riseT < 1) {
          g.userData.__riseT += dt * 1.2;
          g.position.y = Math.sin(g.userData.__riseT * Math.PI) * 0.15;
        } else if (g.userData.__riseT !== undefined) {
          g.userData.__riseT = 1;
          g.position.y *= 0.95; // settle back
        }
      }

      // message fade in/out
      for (const sprite of activeMessages) {
        const f = sprite.userData.fade;
        if (!f) continue;
        f.t += dt * (f.dir > 0 ? 2 : -2);
        sprite.material.opacity = Math.min(1, f.t);
        if (f.t >= 1) { /* keep */ }
      }

      // update & cull fairy dust
      for (let i = dustBursts.length - 1; i >= 0; i--) {
        const pts = dustBursts[i];
        const t = clock.getElapsedTime() - pts.userData.birth;
        const pos = pts.geometry.attributes.position;
        const vel = pts.geometry.attributes.velocity;
        for (let j = 0; j < pos.count; j++) {
          const idx = j * 3;
          pos.array[idx + 0] += vel.array[idx + 0] * dt;
          pos.array[idx + 1] += vel.array[idx + 1] * dt;
          pos.array[idx + 2] += vel.array[idx + 2] * dt;
          vel.array[idx + 1] -= 0.98 * dt * 0.4; // gravity
        }
        pts.material.opacity = Math.max(0, 1 - t * 1.2);
        pos.needsUpdate = true;
        if (pts.material.opacity <= 0.02) {
          scene.remove(pts); pts.geometry.dispose(); pts.material.dispose();
          dustBursts.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // ----- Resize ------------------------------------------------------------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ----- UI helpers --------------------------------------------------------
    function showToast(msg) {
      const t = document.getElementById("toast");
      t.textContent = msg;
      t.style.opacity = 1;
      setTimeout(() => (t.style.opacity = 0), 2800);
    }

    // Hide loading once first frame draws
    renderer.domElement.addEventListener("webglcontextrestored", () => showToast("WebGL context restored"), { once: true });
    setTimeout(() => { const l = document.getElementById("loading"); if (l) l.remove(); }, 400);

  })();
  </script>
</body>
</html>
