<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Birthday City â€“ Game Preview</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#101218}
  #ui{
    position:fixed;inset:0;pointer-events:none;display:flex;align-items:flex-start;justify-content:center;
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;color:#fff
  }
  #hud{
    margin-top:14px;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);
    border-radius:12px;padding:10px 14px;font-size:14px;line-height:1.4;pointer-events:auto
  }
  #hint{opacity:.9}
  #msg{
    position:fixed;left:50%;top:20px;transform:translateX(-50%);
    background:rgba(0,0,0,.7);padding:10px 16px;border-radius:12px;display:none
  }
  #start{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.8)
  }
  #start button{
    pointer-events:auto;font-size:16px;border:0;border-radius:12px;padding:12px 18px;cursor:pointer
  }
  #crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);opacity:.45}
  #crosshair:after{content:"+";font-size:22px;color:#fff}
</style>
</head>
<body>
<div id="start"><button id="enter">Click to enter â€“ then use mouse + WASD</button></div>
<div id="ui"><div id="hud">
  <div id="hint"><b>Controls:</b> Click to lock mouse â€¢ WASD/Arrows to move â€¢ Space to jump â€¢ Shift to run</div>
</div></div>
<div id="msg"></div>
<div id="crosshair"></div>

<script src="three.min.js"></script>
<script src="PointerLockControls.js"></script>
<script>
/* ------- basic scene ------- */
let camera, scene, renderer, controls;
let velocity = new THREE.Vector3(), direction = new THREE.Vector3();
let canJump = false, onFloor = false;
const objects = [];          // colliders (buildings)
const gifts   = [];          // gift meshes
const tmpBox  = new THREE.Box3();
const playerBox = new THREE.Box3();
const gravity = 30;          // stronger gravity for snappy feel
const speedWalk = 14, speedRun = 24, jumpVel = 11;
let moveF=false, moveB=false, moveL=false, moveR=false, run=false;

init(); animate();

function init(){
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x87c9ff, 120, 420);

  camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 3, 10);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // lights
  scene.add(new THREE.HemisphereLight(0xbfd9ff, 0x404040, 0.95));
  const sun = new THREE.DirectionalLight(0xffffff, 0.85);
  sun.position.set(60,120,40);
  sun.castShadow = true;
  sun.shadow.camera.top=120; sun.shadow.camera.bottom=-120; sun.shadow.camera.left=-120; sun.shadow.camera.right=120;
  scene.add(sun);

  // ground with subtle road grid (procedural canvas texture)
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(800,800),
    new THREE.MeshPhongMaterial({map: makeRoadTexture(), depthWrite:true})
  );
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // create a believable city blockout with window textures (not purple)
  createCity();

  // add 2 hoardings using your images (CORS-safe dl.dropboxusercontent)
  addHoarding(new THREE.Vector3(0, 18, -18), 14, 9,
    "https://dl.dropboxusercontent.com/scl/fi/cov38hf9qc6cy4e4c4io9/IMG-20250815-WA0000.jpg?rlkey=8b4oa8vuje8464x6fucpv5xto&st=odlchui1&dl=1");
  addHoarding(new THREE.Vector3(-36, 22, 8), 12, 8,
    "https://dl.dropboxusercontent.com/scl/fi/0a1ckwv332kos7s2koy3n/IMG-20250815-WA0003.jpg?rlkey=m4bcqn577zxvq69qt8gotci7y&st=s7d3k3jh&dl=1");

  // gifts to collect
  addGift(new THREE.Vector3(4, 1, -6), "A little sparkle for your day âœ¨");
  addGift(new THREE.Vector3(-10, 1, 12), "You are lovedâ€”today & always ðŸ’–");
  addGift(new THREE.Vector3(-32, 1, -22), "Happy Birthday, Guddu! ðŸŽ‚");

  // pointer lock setup
  controls = new THREE.PointerLockControls(camera, document.body);
  document.getElementById('enter').addEventListener('click', () => { controls.lock(); document.getElementById('start').style.display='none'; });
  controls.addEventListener('unlock', () => { document.getElementById('start').style.display='flex'; });

  // input
  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);

  window.addEventListener('resize', onResize);
}

/* ------- city generation ------- */
function makeWindowTexture(){
  // procedural windows: dark facade + random lit windows
  const s=128, c=document.createElement('canvas'); c.width=c.height=s;
  const ctx=c.getContext('2d');
  ctx.fillStyle='#3a3f55'; ctx.fillRect(0,0,s,s);            // facade
  ctx.fillStyle='#1e2233'; for(let x=0;x<s;x+=8){ for(let y=0;y<s;y+=8){ ctx.fillRect(x+1,y+1,6,6); } }
  // random lights
  for(let x=0;x<s;x+=8){ for(let y=0;y<s;y+=8){
    if(Math.random()<0.22){ ctx.fillStyle = Math.random()<0.5 ? '#ffd18a' : '#fff3c8'; ctx.fillRect(x+1,y+1,6,6); }
  }}
  const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(1,4);
  return tex;
}
function makeRoadTexture(){
  const s=512, c=document.createElement('canvas'); c.width=c.height=s;
  const x=c.getContext('2d'); x.fillStyle='#3c3f44'; x.fillRect(0,0,s,s);
  x.strokeStyle='rgba(255,255,255,.08)'; x.lineWidth=1;
  for(let i=0;i<=s;i+=32){ x.beginPath(); x.moveTo(i,0); x.lineTo(i,s); x.stroke(); x.beginPath(); x.moveTo(0,i); x.lineTo(s,i); x.stroke(); }
  const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(20,20);
  return tex;
}
function createCity(){
  const mat = new THREE.MeshPhongMaterial({map: makeWindowTexture(), shininess: 8});
  const rng = (a,b)=>a+Math.random()*(b-a);
  for(let gx=-4; gx<=4; gx++){
    for(let gz=-4; gz<=4; gz++){
      if(Math.random()<0.25) continue; // leave some streets open
      const w = rng(8,14), d = rng(8,14), h = rng(10,36);
      const b = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
      b.position.set(gx*18, h/2, gz*18);
      b.castShadow = true; b.receiveShadow = true;
      scene.add(b);
      objects.push(b);  // for collision
    }
  }
}

/* ------- hoardings ------- */
function addHoarding(pos, w, h, url){
  const loader = new THREE.TextureLoader();
  loader.load(url, (tex)=>{
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;
    const m = new THREE.MeshBasicMaterial({map: tex});
    const p = new THREE.Mesh(new THREE.PlaneGeometry(w,h), m);
    p.position.copy(pos);
    // face toward camera start area
    p.lookAt(new THREE.Vector3(0, pos.y, 40));
    p.renderOrder = 2;
    scene.add(p);
  }, undefined, ()=>console.warn('Failed to load hoarding image:', url));
}

/* ------- gifts ------- */
function addGift(pos, message){
  const box = new THREE.Mesh(new THREE.BoxGeometry(1.4,1.4,1.4),
    new THREE.MeshStandardMaterial({color:0xff4d88, roughness:.45, metalness:.1}));
  const ribbon = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.16,0.3),
    new THREE.MeshStandardMaterial({color:0xffffff, roughness:.3}));
  ribbon.position.y = 0.8; box.add(ribbon);
  box.position.copy(pos); box.castShadow=true; scene.add(box);
  gifts.push({mesh:box, msg:message, collected:false, ttl:0});
}

/* ------- input handlers ------- */
function onKeyDown(e){
  switch(e.code){
    case 'ArrowUp': case 'KeyW': moveF=true; break;
    case 'ArrowLeft': case 'KeyA': moveL=true; break;
    case 'ArrowDown': case 'KeyS': moveB=true; break;
    case 'ArrowRight': case 'KeyD': moveR=true; break;
    case 'Space': if(canJump){ velocity.y = jumpVel; canJump=false; } break;
    case 'ShiftLeft': case 'ShiftRight': run=true; break;
  }
}
function onKeyUp(e){
  switch(e.code){
    case 'ArrowUp': case 'KeyW': moveF=false; break;
    case 'ArrowLeft': case 'KeyA': moveL=false; break;
    case 'ArrowDown': case 'KeyS': moveB=false; break;
    case 'ArrowRight': case 'KeyD': moveR=false; break;
    case 'ShiftLeft': case 'ShiftRight': run=false; break;
  }
}
function onResize(){
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
}

/* ------- simple physics & collisions ------- */
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.05, clock.getDelta());

  // movement
  direction.set(0,0,0);
  if(moveF) direction.z -= 1;
  if(moveB) direction.z += 1;
  if(moveL) direction.x -= 1;
  if(moveR) direction.x += 1;
  direction.normalize();

  const speed = (run?speedRun:speedWalk) * dt;
  const yaw = new THREE.Quaternion(); yaw.setFromEuler(new THREE.Euler(0, camera.rotation.y, 0));
  const step = direction.clone().applyQuaternion(yaw).multiplyScalar(speed);

  // apply gravity
  velocity.y -= gravity * dt;

  // attempt move and collide against buildings (AABB)
  const nextPos = camera.position.clone().add(step);
  // player volume (capsule approximated by box)
  playerBox.setFromCenterAndSize(nextPos.clone().add(new THREE.Vector3(0,1,0)), new THREE.Vector3(1,2,1));
  let blocked = false;
  for(const o of objects){
    tmpBox.setFromObject(o);
    if(tmpBox.intersectsBox(playerBox)){ blocked = true; break; }
  }
  if(!blocked) camera.position.copy(nextPos);

  // floor
  const yFloor = 1.0; // eye height minus half "capsule"
  camera.position.y += velocity.y * dt;
  if(camera.position.y < yFloor){
    velocity.y = 0; camera.position.y = yFloor; canJump = true; onFloor = true;
  } else { onFloor = false; }

  // gift proximity / collect
  for(const g of gifts){
    if(g.collected) continue;
    if(camera.position.distanceTo(g.mesh.position) < 2.0){
      g.collected = true; g.ttl = 1.2; sparkle(g.mesh.position); scene.remove(g.mesh);
      chime(); showMsg(g.msg);
    }
  }

  renderer.render(scene, camera);
}

/* ------- fairy dust + sound (no external files) ------- */
function sparkle(origin){
  const geom = new THREE.SphereGeometry(0.05, 6, 6);
  const group = new THREE.Group(); scene.add(group);
  for(let i=0;i<90;i++){
    const m = new THREE.MeshBasicMaterial({color:0xffe0ff, transparent:true, opacity:1});
    const p = new THREE.Mesh(geom, m);
    p.position.copy(origin);
    p.userData.v = new THREE.Vector3((Math.random()-0.5)*3, Math.random()*3, (Math.random()-0.5)*3);
    group.add(p);
  }
  const t0 = performance.now();
  (function tick(){
    const t = (performance.now()-t0)/1000;
    for(const p of group.children){
      p.position.addScaledVector(p.userData.v, 0.016);
      p.userData.v.y -= 3*0.016;
      p.material.opacity = Math.max(0, 1 - t);
    }
    if(t<1.0) requestAnimationFrame(tick); else scene.remove(group);
  })();
}
function chime(){
  const ac = new (window.AudioContext||window.webkitAudioContext)();
  const o = ac.createOscillator(), g = ac.createGain();
  o.type='triangle'; o.frequency.setValueAtTime(880, ac.currentTime);
  g.gain.setValueAtTime(0.0001, ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.2, ac.currentTime+0.02);
  g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+0.5);
  o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime+0.6);
}

/* ------- small UI helpers ------- */
function showMsg(t){
  const el = document.getElementById('msg'); el.textContent=t; el.style.display='block';
  clearTimeout(showMsg.tid); showMsg.tid = setTimeout(()=>el.style.display='none', 3500);
}
</script>
</body>
</html>
